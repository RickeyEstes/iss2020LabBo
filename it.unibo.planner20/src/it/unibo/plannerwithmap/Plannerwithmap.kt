/* Generated by AN DISI Unibo */ 
package it.unibo.plannerwithmap

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Plannerwithmap ( name: String, scope: CoroutineScope  ) : ActorBasicFsm( name, scope ){

	override fun getInitialState() : String{
		return "s0"
	}
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi			
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		  var CurrentPlannedMove = ""
			val mapname                    = "roomMap"
			var storedPos  : Pair<Int,Int> = Pair(0,0)
			var planInterrupted            = false
			var StepTime                   = 500L
			val TargetPos                  = Pair(4,4)
		return { //this:ActionBasciFsm
				state("s0") { //this:State
					action { //it:State
						println("&&&  plannerwithmap STARTED")
						itunibo.planner.plannerUtil.initAI(  )
						itunibo.planner.moveUtils.loadRoomMap( mapname  )
						println("INITIAL MAP")
						itunibo.planner.moveUtils.showMap(  )
						 
									emitWithDelay("alarm", "alarm(fire)",1000L)
					}
					 transition( edgeName="goto",targetState="moveToTargetPoint", cond=doswitch() )
				}	 
				state("moveToTargetPoint") { //this:State
					action { //it:State
						itunibo.planner.plannerUtil.planForGoal( "${TargetPos.first}", "${TargetPos.second}"  )
					}
					 transition( edgeName="goto",targetState="execPlannedMoves", cond=doswitch() )
				}	 
				state("execPlannedMoves") { //this:State
					action { //it:State
						  CurrentPlannedMove = itunibo.planner.plannerUtil.getNextPlannedMove()  
						if(  CurrentPlannedMove.length > 0  
						 ){forward("doMove", "doMove($CurrentPlannedMove)" ,"plannerwithmap" ) 
						}
						else
						 {println("&&&  plannerwithmap POINT ${TargetPos.first},${TargetPos.second} REACHED")
						 itunibo.planner.plannerUtil.showCurrentRobotState(  )
						 }
					}
					 transition(edgeName="t00",targetState="handleAlarm",cond=whenEvent("alarm"))
					transition(edgeName="t01",targetState="execTheMove",cond=whenDispatch("doMove"))
				}	 
				state("handleAlarm") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						 planInterrupted = true
						 			storedPos = itunibo.planner.plannerUtil.get_curPos() 
						 			itunibo.planner.plannerUtil.memoCurentPlan()
						itunibo.planner.plannerUtil.showCurrentRobotState(  )
						request("movetoCell", "movetoCell(0,0)" ,"walker" )  
					}
					 transition(edgeName="t02",targetState="backToHome",cond=whenReply("atcell"))
				}	 
				state("backToHome") { //this:State
					action { //it:State
						println("plannerwithmap backToHome")
						if(  planInterrupted  
						 ){ val XOLD = storedPos.first
									   val YOLD = storedPos.second	
						request("movetoCell", "movetoCell($XOLD,$YOLD)" ,"walker" )  
						}
					}
					 transition(edgeName="t03",targetState="resumeOldPlan",cond=whenReply("atcell"))
				}	 
				state("execTheMove") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("doMove(V)"), Term.createTerm("doMove(M)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								delay(StepTime)
								 val move = payloadArg(0)
								  			   itunibo.planner.plannerUtil.updateMap(move,"plannerwithmap: exec $move") 			   
						}
					}
					 transition( edgeName="goto",targetState="execPlannedMoves", cond=doswitch() )
				}	 
				state("resumeOldPlan") { //this:State
					action { //it:State
						println("-------------------------------------------------------------------")
						println("plannerwithmap resumeOldPlan to reach POINT ${TargetPos.first},${TargetPos.second}")
						println("-------------------------------------------------------------------")
						itunibo.planner.plannerUtil.showCurrentRobotState(  )
						itunibo.planner.plannerUtil.restorePlan(  )
						 readLine()  
						 
									emitWithDelay("alarm", "alarm(fire)",2000L)
						stateTimer = TimerActor("timer_resumeOldPlan", 
							scope, context!!, "local_tout_plannerwithmap_resumeOldPlan", 50.toLong() )
					}
					 transition(edgeName="t04",targetState="execPlannedMoves",cond=whenTimeout("local_tout_plannerwithmap_resumeOldPlan"))   
					transition(edgeName="t05",targetState="execTheOldMove",cond=whenDispatch("doMove"))
				}	 
				state("execTheOldMove") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("doMove(V)"), Term.createTerm("doMove(M)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								delay(StepTime)
								 val move = payloadArg(0)
								  			   itunibo.planner.plannerUtil.updateMap(move,"plannerwithmap: OLD MOVE $move")
						}
						stateTimer = TimerActor("timer_execTheOldMove", 
							scope, context!!, "local_tout_plannerwithmap_execTheOldMove", 50.toLong() )
					}
					 transition(edgeName="t06",targetState="execPlannedMoves",cond=whenTimeout("local_tout_plannerwithmap_execTheOldMove"))   
					transition(edgeName="t07",targetState="execTheOldMove",cond=whenDispatch("doMove"))
				}	 
				state("execOldPlannedMove") { //this:State
					action { //it:State
						println("plannerwithmap execOldPlannedMove")
						 readLine()  
						stateTimer = TimerActor("timer_execOldPlannedMove", 
							scope, context!!, "local_tout_plannerwithmap_execOldPlannedMove", 50.toLong() )
					}
					 transition(edgeName="t08",targetState="execPlannedMoves",cond=whenTimeout("local_tout_plannerwithmap_execOldPlannedMove"))   
					transition(edgeName="t09",targetState="execOldPlannedMove",cond=whenDispatch("doMove"))
				}	 
				state("discardOldMoveTodo") { //this:State
					action { //it:State
						println("plannerwithmap discardOldMovesTodo")
						stateTimer = TimerActor("timer_discardOldMoveTodo", 
							scope, context!!, "local_tout_plannerwithmap_discardOldMoveTodo", 50.toLong() )
					}
					 transition(edgeName="t010",targetState="execPlannedMoves",cond=whenTimeout("local_tout_plannerwithmap_discardOldMoveTodo"))   
					transition(edgeName="t011",targetState="discardOldMoveTodo",cond=whenDispatch("doMove"))
				}	 
			}
		}
}
