/*
 * robotmapper.qak
 * ANALYSIS MODEL
 */
System robotmapper 

Dispatch start   : start(ARG)
Dispatch stop    : stop(ARG)
Dispatch resume  : resume(ARG) 
Dispatch cmd     : cmd(MOVE)
Dispatch end     : end(ARG)
 
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)
  
Context ctxrobotmapper   ip [host="localhost" port=8030]  
Context ctxbasicrobot    ip [host="192.168.1.68" port=8020] 
  
ExternalQActor basicrobot context ctxbasicrobot 
 
QActor robotmapper context ctxrobotmapper  {   
  	
[# 
var NumStep      = 0  
var GoalOk       = true
val StepTime     = 350
var StartTime    = 0L
var Workduration = 0L    
var CurrentPlannedMove = ""
val mapname      = "roomMbot3"
#] 

	State s0 initial { 	  
		println("robotmapper | START")	
		discardMsg Off  //WE MUST RECEIVE stop
//		println("${mapRoomKotlin.mapUtil.refMapForTesting}")
//		println("-----------------")
//		run mapRoomKotlin.mapUtil.showMap()  //initial map empty 
//		delay 2000  //just to look at the reference map and the current map

		//run itunibo.planner.moveUtils.showCurrentRobotState()
		run itunibo.planner.plannerUtil.initAI()
 		forward basicrobot -m cmd : cmd(l)
		delay 300
		forward basicrobot -m cmd : cmd(r)    
		delay 300
		qrun itunibo.planner.moveUtils.loadRoomMap(myself,mapname)
		updateResource [# "initial" #]
	}	
 	Goto exploreDirties //explore  //goAhead  
 	
 	 
 	State exploreDirties{
 		run itunibo.planner.plannerUtil.resetActions()
 		run itunibo.planner.plannerUtil.setPlanForNextDirty()
 	}
 	Goto execPlannedMoves if [# itunibo.planner.plannerUtil.existActions() #] else endOfJob 


 	   
 	State explore{
 		[# 
 		   if( GoalOk ) NumStep++ else  GoalOk = true  //mainatin the goal after a failure
 		#]  //could maintain the current goal
 		
 		println("robotmapper | EXPLORING ... $NumStep  ")	
 		run itunibo.planner.plannerUtil.planForGoal("${NumStep}","${NumStep}") 		 
 		//run itunibo.planner.moveUtils.showCurrentRobotState()
  		//delay 1000
 		[# readLine()  #] 
 	}  
 	Goto execPlannedMoves if [# itunibo.planner.plannerUtil.existActions() && NumStep < 11 #] 
 	                      else endWork 
  	
 	State execPlannedMoves{ 
 		[#  CurrentPlannedMove = itunibo.planner.plannerUtil.getNextPlannedMove() 
 			//println("			execPlannedMovessssss = $CurrentPlannedMove")
  		#]
 	}
 	Goto wMove if [# CurrentPlannedMove == "w" #] else otherPlannedMove
 
 	State wMove {  
 		//println("wMove")  
 		request basicrobot -m step : step( $StepTime  )
 	}
 	Transition t0  whenReply stepdone -> stepDone
				   whenReply stepfail -> stepFail

 	
 	State otherPlannedMove{
 		//println("otherPlannedMove $CurrentPlannedMove")
 		if [# CurrentPlannedMove == "l" || CurrentPlannedMove == "r"  #]{
 			forward basicrobot -m cmd : cmd($CurrentPlannedMove) 
 			delay 500
			qrun itunibo.planner.moveUtils.doPlannedMove(myself,"$CurrentPlannedMove")
			//run itunibo.planner.moveUtils.showCurrentRobotState()
  		} 
 	}   
 	Goto execPlannedMoves  if [# CurrentPlannedMove.length > 0 #] else exploreDirties//continueWork //backToHome
  	
  	
  	State continueWork{
  		if [# ! itunibo.planner.moveUtils.atHome() #]{ 
    		println("TARGET CELL REACHED ----------- ") 			
  			[# NumStep++ #]
  			run itunibo.planner.plannerUtil.planForGoal("${NumStep}","${NumStep}") 
  		}else{
  			println("AT HOME AGAIN ----------- ") 	
  			run itunibo.planner.plannerUtil.resetActions() 
  			[# GoalOk=true #]
  		}
  		delay 1000
  		[# readLine()  #]  
  	}
  	Goto execPlannedMoves if [# itunibo.planner.plannerUtil.existActions() #] else explore //atHomeAgain 
  	
  	
//  	State atHomeAgain{
//  		println("AT HOME AGAIN ----------- ") 			  		
//  	}
//  	Goto explore
  	
	State backToHome{
		println("GOING BACK to HOME ... ")
 		if [# ! itunibo.planner.moveUtils.atHome() #]{
 			run itunibo.planner.plannerUtil.planForGoal("0","0")
 		}else{
 			println("AT HOME !!")
 		}
  		delay 1000
  		//[# readLine()  #]  
	}  
	//Goto  explore if [# itunibo.planner.moveUtils.atHome() #] else execPlannedMoves
	Goto  endWork if [# itunibo.planner.moveUtils.atHome() #] else execPlannedMoves
	
	State stepDone{ //change the map
	    //println("robotmapper | stepDone  ")   
	    updateResource [# "stepDone " #]
  	    qrun itunibo.planner.moveUtils.doPlannedMove(myself,"w")
// 		delay 300
 	} 
	Goto execPlannedMoves  
 	
 	
	State stepFail{
	    println("				robotmapper | stepFail  ")
		//printCurrentMessage
		[#
			GoalOk = false
			var Dt = 0L 			
		#]     
		onMsg(stepfail : stepfail(DURATION, CAUSE) ){
			[# Dt = payloadArg(0).toLong()  #] 
			//println("robotmapper stepFail after: $Dt vs ${3*StepTime/4.0}")
			if [# Dt < 3*StepTime/4.0  #] {    
				forward basicrobot -m cmd : cmd( s )
				delayVar Dt
				forward basicrobot -m cmd : cmd( h )
			}	
//	 		if [# ! itunibo.planner.moveUtils.atHome() #]{
	 			qrun itunibo.planner.moveUtils.setObstacleOnCurrentDirection(myself)
//	 		}
	 		run itunibo.planner.moveUtils.showCurrentRobotState()
			updateResource [# "stepFail" #]
			//delay 500	
		}	    
  	}
//  	Goto execPlannedMoves if [# itunibo.planner.plannerUtil.getActions().size>0 #] else endWork 
 	Goto exploreDirties //backToHome
 
  	
	 
 	State endWork{
 		setDuration Workduration from StartTime
		println("robotmapper | ends; duration=$Workduration")
		updateResource [# "terminated" #]
		terminate 0
 	}

	
	State endOfJob{
		run itunibo.planner.plannerUtil.getDuration()
	}
	Goto backToHome
}

/*
//	State stopped{ 
//		println("robotmapper | stopped")	
//		updateResource [# "stopped" #]
//	}
//	Transition t0 whenMsg resume  -> work
// 
  	State goAhead{
 		request basicrobot -m step : step( $StepTime  )
 	}
 	Transition t0  whenReply stepdone -> aheadOk
				   whenReply stepfail -> aheadFail
 	
 	State aheadOk{
 		run itunibo.planner.moveUtils.showCurrentRobotState()
 		qrun itunibo.planner.moveUtils.doPlannedMove(myself,"w")
 		delay 200
 	}
 	Goto goAhead 
 	
 	State aheadFail{
 		println("				robotmapper | aheadFail  ")
		onMsg(stepfail : stepfail(DURATION, CAUSE) ){
			[# var Dt = payloadArg(0).toLong()  #] 
			//println("robotmapper stepFail after: $Dt vs ${3*StepTime/4.0}")
			if [# Dt < 3*StepTime/4.0  #] {    
				forward basicrobot -m cmd : cmd( s )
				delayVar Dt
				forward basicrobot -m cmd : cmd( h )
			}			
		}	
 		updateResource [# "aheadFail" #]
 		if [# ! itunibo.planner.moveUtils.atHome() #]{
 			qrun itunibo.planner.moveUtils.setObstacleOnCurrentDirection(myself)
 		}
 		run itunibo.planner.moveUtils.showCurrentRobotState()
 	}
 	Goto backToHome if [# ! itunibo.planner.moveUtils.atHome() #] else atHomeAgain
 	
  	State atHomeAgain{
 		[# NumStep++ #]
 		println("AT HOME AGAIN !!! ... $NumStep")
 		forward basicrobot -m cmd : cmd( r )
  		delay 500
 		qrun itunibo.planner.moveUtils.doPlannedMove(myself,"r")
  		forward basicrobot -m cmd : cmd( l )
   		delay 500
   		qrun itunibo.planner.moveUtils.doPlannedMove(myself,"r")
 		run itunibo.planner.moveUtils.showCurrentRobotState()		
 	}
 	Goto goAhead if [# NumStep < 4 #] else endWork
 
 */
 